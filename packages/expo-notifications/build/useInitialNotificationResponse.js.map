{"version":3,"file":"useInitialNotificationResponse.js","sourceRoot":"","sources":["../src/useInitialNotificationResponse.ts"],"names":[],"mappings":"AAAA,OAAO,EAAgB,YAAY,EAAE,MAAM,kBAAkB,CAAC;AAC9D,OAAO,EAAE,SAAS,EAAE,eAAe,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAG7D,OAAO,EAAE,uCAAuC,EAAE,MAAM,wBAAwB,CAAC;AAEjF,6CAA6C;AAC7C,kCAAkC;AAClC,MAAM,gBAAgB,GAAG;IACvB,WAAW,EAAE,GAAG,EAAE,GAAE,CAAC;IACrB,eAAe,EAAE,GAAG,EAAE,GAAE,CAAC;CAC1B,CAAC;AACF,4CAA4C;AAC5C,gDAAgD;AAChD,yCAAyC;AACzC,MAAM,YAAY,GAAG,IAAI,YAAY,CAAC,gBAAgB,CAAC,CAAC;AACxD,MAAM,mBAAmB,GAAG,UAAU,CAAC;AAEvC,0CAA0C;AAC1C,sBAAsB;AACtB,IAAI,iCAAiC,GAAqC,SAAS,CAAC;AAEpF,oDAAoD;AACpD,qDAAqD;AACrD,0DAA0D;AAC1D,4CAA4C;AAC5C,IAAI,kBAAkB,GAAwB,uCAAuC,CAAC,QAAQ,CAAC,EAAE;IAC/F,qEAAqE;IACrE,YAAY;IACZ,YAAY,CAAC,IAAI,CAAC,mBAAmB,EAAE,QAAQ,CAAC,CAAC;IACjD,2EAA2E;IAC3E,2BAA2B;IAC3B,iCAAiC,GAAG,QAAQ,CAAC;IAC7C,iCAAiC,EAAE,CAAC;AACtC,CAAC,CAAC,CAAC;AAEH,SAAS,iCAAiC;IACxC,IAAI,kBAAkB,EAAE;QACtB,kBAAkB,CAAC,MAAM,EAAE,CAAC;QAC5B,kBAAkB,GAAG,IAAI,CAAC;KAC3B;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,CAAC,OAAO,UAAU,8BAA8B;IACpD,MAAM,CAAC,2BAA2B,EAAE,8BAA8B,CAAC,GAAG,QAAQ,CAE5E,iCAAiC,CAAC,CAAC;IAErC,eAAe,CAAC,GAAG,EAAE;QACnB,6DAA6D;QAC7D,MAAM,YAAY,GAAG,YAAY,CAAC,WAAW,CAC3C,mBAAmB,EACnB,QAAQ,CAAC,EAAE;YACT,8BAA8B,CAAC,eAAe,CAAC,EAAE,CAAC,eAAe,IAAI,QAAQ,CAAC,CAAC;QACjF,CAAC,CACF,CAAC;QACF,oDAAoD;QACpD,8DAA8D;QAC9D,8BAA8B,CAC5B,eAAe,CAAC,EAAE,CAAC,eAAe,IAAI,iCAAiC,CACxE,CAAC;QACF,yCAAyC;QACzC,OAAO,GAAG,EAAE,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC;IACrC,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,SAAS,CAAC,GAAG,EAAE;QACb,iDAAiD;QACjD,kDAAkD;QAClD,wBAAwB;QACxB,UAAU,CAAC,GAAG,EAAE;YACd,kDAAkD;YAClD,iCAAiC;YACjC,iCAAiC,EAAE,CAAC;YACpC,qDAAqD;YACrD,sEAAsE;YACtE,8BAA8B,CAAC,eAAe,CAAC,EAAE,CAAC,eAAe,IAAI,IAAI,CAAC,CAAC;QAC7E,CAAC,EAAE,CAAC,CAAC,CAAC;IACR,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,2BAA2B,CAAC;AACrC,CAAC","sourcesContent":["import { Subscription, EventEmitter } from '@unimodules/core';\nimport { useEffect, useLayoutEffect, useState } from 'react';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\n\n// We need any native module for EventEmitter\n// to be able to be subscribed to.\nconst MockNativeModule = {\n  addListener: () => {},\n  removeListeners: () => {},\n};\n// Event emitter used solely for the purpose\n// of distributing initial notification response\n// to useInitialNotificationResponse hook\nconst eventEmitter = new EventEmitter(MockNativeModule);\nconst RESPONSE_EVENT_TYPE = 'response';\n\n// Initial notification response caught by\n// global subscription\nlet globalInitialNotificationResponse: NotificationResponse | undefined = undefined;\n\n// A subscription for initial notification response,\n// cleared immediately once we believe we have caught\n// the initial notification response or there will be none\n// (by useInitialNotificationResponse hook).\nlet globalSubscription: Subscription | null = addNotificationResponseReceivedListener(response => {\n  // If useInitialNotificationResponse is already registered we want to\n  // notify it\n  eventEmitter.emit(RESPONSE_EVENT_TYPE, response);\n  // If useInitialNotificationResponse isn't registered yet, we'll provide it\n  // with good initial value.\n  globalInitialNotificationResponse = response;\n  ensureGlobalSubscriptionIsCleared();\n});\n\nfunction ensureGlobalSubscriptionIsCleared() {\n  if (globalSubscription) {\n    globalSubscription.remove();\n    globalSubscription = null;\n  }\n}\n\n/**\n * Returns an initial notification response if the app\n * was opened as a result of tapping on a notification,\n * null if the app doesn't seem to be opened as a result\n * of tapping on a notification, undefined until we are sure\n * of which to return.\n */\nexport default function useInitialNotificationResponse() {\n  const [initialNotificationResponse, setInitialNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(globalInitialNotificationResponse);\n\n  useLayoutEffect(() => {\n    // Register for internal initial notification response events\n    const subscription = eventEmitter.addListener<NotificationResponse>(\n      RESPONSE_EVENT_TYPE,\n      response => {\n        setInitialNotificationResponse(currentResponse => currentResponse ?? response);\n      }\n    );\n    // In case global subscription has already triggered\n    // and we missed the eventEmitter notification reset the value\n    setInitialNotificationResponse(\n      currentResponse => currentResponse ?? globalInitialNotificationResponse\n    );\n    // Clear the subscription as hook cleanup\n    return () => subscription.remove();\n  }, []);\n\n  useEffect(() => {\n    // process.nextTick & requestAnimationFrame-like,\n    // without this on iOS the subscription is cleared\n    // before it's triggered\n    setTimeout(() => {\n      // If there was an \"initial notification response\"\n      // it has already been delivered.\n      ensureGlobalSubscriptionIsCleared();\n      // Ensure the value is not undefined (if by this time\n      // it's still undefined there was no \"initial notification response\").\n      setInitialNotificationResponse(currentResponse => currentResponse ?? null);\n    }, 0);\n  }, []);\n\n  return initialNotificationResponse;\n}\n"]}